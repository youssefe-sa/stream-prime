"""Utility to convert the extracted channel list text into structured JSON/TS files.

Usage:
    python scripts\build_channels_data.py

This script expects `channel_list_full.txt` at the project root (generated by
`scripts/extract_channels.py`). It produces two artifacts:
  - `src/data/channelSections.json`
  - `src/data/channelSections.ts`
Both contain an array of { title, entries[] } objects that group channel names
by the headings detected in the source document.
"""
from __future__ import annotations

import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

BASE_DIR = Path(__file__).resolve().parent.parent
RAW_TEXT_PATH = BASE_DIR / "channel_list_full.txt"
OUTPUT_JSON_PATH = BASE_DIR / "src/data/channelSections.json"
OUTPUT_TS_PATH = BASE_DIR / "src/data/channelSections.ts"

HEADER_REGEX = re.compile(r"^#+\s*(.*?)\s*#+$")
PAGE_MARKER_REGEX = re.compile(r"^=====\s*PAGE\s+\d+\s+=====\s*$", re.IGNORECASE)


@dataclass
class ChannelSection:
    title: str
    entries: List[str]


def normalize_header(line: str) -> str | None:
    if not line:
        return None

    line = line.strip()
    if not line.startswith("#"):
        return None

    match = HEADER_REGEX.match(line)
    if match:
        header = match.group(1)
    else:
        header = line.lstrip("#")

    cleaned = " ".join(header.split())
    return cleaned or None


def parse_sections(lines: Iterable[str]) -> list[ChannelSection]:
    sections: list[ChannelSection] = []
    current: ChannelSection | None = None

    for raw_line in lines:
        line = raw_line.strip()
        if not line or PAGE_MARKER_REGEX.match(line):
            continue

        header = normalize_header(line)
        if header:
            if current and current.entries:
                sections.append(current)
            current = ChannelSection(title=header, entries=[])
            continue

        if current is None:
            current = ChannelSection(title="General", entries=[])

        current.entries.append(line)

    if current and current.entries:
        sections.append(current)

    return sections


def write_json(sections: list[ChannelSection]) -> None:
    payload = [section.__dict__ for section in sections]
    OUTPUT_JSON_PATH.write_text(
        json.dumps(payload, ensure_ascii=False, indent=2),
        encoding="utf-8",
    )
    print(f"Wrote JSON data to {OUTPUT_JSON_PATH}")


def write_ts(sections: list[ChannelSection]) -> None:
    header = "// Auto-generated by scripts/build_channels_data.py\n\n"
    header += "export interface ChannelSection {\n  title: string;\n  entries: string[];\n}\n\n"
    data_literal = json.dumps(
        [section.__dict__ for section in sections],
        ensure_ascii=False,
        indent=2,
    )
    body = f"export const channelSections: ChannelSection[] = {data_literal} as const;\n"
    OUTPUT_TS_PATH.write_text(header + body, encoding="utf-8")
    print(f"Wrote TypeScript data to {OUTPUT_TS_PATH}")


def main() -> None:
    if not RAW_TEXT_PATH.exists():
        raise SystemExit(
            "Missing channel_list_full.txt. Run scripts/extract_channels.py first."
        )

    raw_lines = RAW_TEXT_PATH.read_text(encoding="utf-8", errors="ignore").splitlines()
    sections = parse_sections(raw_lines)
    print(f"Parsed {len(sections)} sections containing {sum(len(s.entries) for s in sections)} entries.")

    OUTPUT_JSON_PATH.parent.mkdir(parents=True, exist_ok=True)
    write_json(sections)
    write_ts(sections)


if __name__ == "__main__":
    main()
